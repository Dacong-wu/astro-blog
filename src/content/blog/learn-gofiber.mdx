---
publishDate: 2024-10-31
title: 学习 fiber(go) 语法
excerpt: 学习 fiber(go) 语法，并对比 js 展示语法差异性
image: '~/assets/images/blog/graham-holtshausen-mchGuXktqAs-unsplash.webp'
category: server
tags:
  - go
  - fiber
metadata:
  image_author:
    link: https://unsplash.com/@freedomstudios
    name: freedomstudios
---

## 1. 为什么使用 `:=`，不用 `=`

1. **`:=`（短变量声明）**：

   - 用于声明一个新的变量并初始化。
   - 当你使用 `:=` 时，编译器会根据右侧表达式的类型自动推导出变量的类型。
   - 只能在函数内部使用。

   例如：

   ```go
   x := 10 // 声明一个新的变量 x，并赋值为 10
   ```

2. **`=`（赋值）**：

   - 用于给一个已经声明的变量赋新值。
   - 在变量已存在的情况下，使用 `=` 来更新变量的值。
   - 可以在函数内部和外部使用。

   例如：

   ```go
   var x int // 声明变量 x
   x = 10    // 赋值
   ```

## 2. 为什么使用 `*fiber.Ctx`，而不直接使用 `fiber.Ctx`

在 Go 语言中，`*fiber.Ctx` 和 `fiber.Ctx` 的主要区别在于是否使用指针。具体来说：

1. **`fiber.Ctx`**：
   - 这是 `fiber.Ctx` 类型的值（value）。
   - 当你使用值类型时，函数会接收到该类型的一个副本。任何对这个副本的修改都不会影响原始对象。
2. **`*fiber.Ctx`**：
   - 这是 `fiber.Ctx` 类型的指针（pointer）。
   - 当你使用指针类型时，函数接收到的是指向 `fiber.Ctx` 对象的地址。这意味着你可以在函数内直接修改这个对象，并且这些修改会反映到原始对象上。

### **为什么使用指针？**

在 Fiber 框架中，选择使用 `*fiber.Ctx` 有几个原因：

1. **性能**：指针传递比值传递更高效，尤其是当对象较大时。通过指针传递，你避免了复制整个对象的开销。
2. **修改对象**：在处理请求时，通常需要修改请求上下文，比如添加响应头、修改状态码等。使用指针可以直接在原始上下文上进行修改，而不必担心修改副本的问题。
3. **一致性**：Fiber 框架的设计决定了所有处理函数都使用指针，这样可以保持一致性，并确保你在每个请求处理程序中使用的是同一个上下文实例。

